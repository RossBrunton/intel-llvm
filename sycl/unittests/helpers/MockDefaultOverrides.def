//==---------- PiMockPlugin.hpp --- Mock unit testing PI plugin ------------==//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// A simple implementation of a PI plugin to be used for device-independent
// mock unit-testing.
//
//===----------------------------------------------------------------------===//

#define ADD_DEFAULT_OVERRIDE(func_name, override) \
addCallbackProperties(ur_callback_layer_properties { \
  UR_STRUCTURE_TYPE_CALLBACK_LAYER_PROPERTIES, \
  nullptr, \
  func_name, \
  UR_CALLBACK_OVERRIDE_MODE_REPLACE, \
  reinterpret_cast<void*>(&func_name) \
});

inline ur_result_t mock_urPlatformGet(ur_adapter_handle_t *, uint32_t,
                                      uint32_t num_entries,
                                      ur_platform_handle_t *platforms,
                                      uint32_t *num_platforms) {
  if (num_platforms)
    *num_platforms = 1;

  if (platforms && num_entries > 0)
    platforms[0] = reinterpret_cast<ur_platform_handle_t>(1);

  return UR_RESULT_SUCCESS;
}

ADD_DEFAULT_OVERRIDE(urPlatformGet, mock_urPlatformGet)

inline ur_result_t mock_urDeviceGet(ur_platform_handle_t platform,
                                    ur_device_type_t device_type,
                                    uint32_t num_entries,
                                    ur_device_handle_t *devices,
                                    uint32_t *num_devices) {
  if (num_devices)
    *num_devices = 1;

  if (devices && num_entries > 0)
    devices[0] = reinterpret_cast<ur_device_handle_t>(1);

  return UR_RESULT_SUCCESS;
}

inline ur_result_t mock_urPlatformGetInfo(ur_platform_handle_t platform,
                                          ur_platform_info_t param_name,
                                          size_t param_value_size,
                                          void *param_value,
                                          size_t *param_value_size_ret) {
  constexpr char MockPlatformName[] = "Mock platform";
  constexpr char MockSupportedExtensions[] =
      "cl_khr_il_program cl_khr_subgroups cl_intel_subgroups "
      "cl_intel_subgroups_short cl_intel_required_subgroup_size ";
  switch (param_name) {
  case UR_PLATFORM_INFO_NAME: {
    if (param_value) {
      assert(param_value_size == sizeof(MockPlatformName));
      std::memcpy(param_value, MockPlatformName, sizeof(MockPlatformName));
    }
    if (param_value_size_ret)
      *param_value_size_ret = sizeof(MockPlatformName);
    return UR_RESULT_SUCCESS;
  }
  case UR_PLATFORM_INFO_EXTENSIONS: {
    if (param_value) {
      assert(param_value_size == sizeof(MockSupportedExtensions));
      std::memcpy(param_value, MockSupportedExtensions,
                  sizeof(MockSupportedExtensions));
    }
    if (param_value_size_ret)
      *param_value_size_ret = sizeof(MockSupportedExtensions);
    return UR_RESULT_SUCCESS;
  }
  case UR_PLATFORM_INFO_BACKEND: {
    constexpr auto MockPlatformBackend = UR_PLATFORM_BACKEND_OPENCL;
    if (param_value) {
      std::memcpy(param_value, &MockPlatformBackend,
                  sizeof(MockPlatformBackend));
    }
    if (param_value_size_ret)
      *param_value_size_ret = sizeof(MockPlatformBackend);
    return UR_RESULT_SUCCESS;
  }
  default: {
    constexpr const char FallbackValue[] = "str";
    constexpr size_t FallbackValueSize = sizeof(FallbackValue);
    if (param_value_size_ret)
      *param_value_size_ret = FallbackValueSize;

    if (param_value && param_value_size >= FallbackValueSize)
      std::memcpy(param_value, FallbackValue, FallbackValueSize);

    return UR_RESULT_SUCCESS;
  }
  }
}

inline ur_result_t mock_urDeviceGetInfo(ur_device_handle_t device,
                                        ur_device_info_t param_name,
                                        size_t param_value_size,
                                        void *param_value,
                                        size_t *param_value_size_ret) {
  constexpr char MockDeviceName[] = "Mock device";
  constexpr char MockSupportedExtensions[] =
      "cl_khr_fp64 cl_khr_fp16 cl_khr_il_program ur_exp_command_buffer";
  switch (param_name) {
  case UR_DEVICE_INFO_TYPE: {
    // Act like any device is a GPU.
    // TODO: Should we mock more device types?
    if (param_value)
      *static_cast<ur_device_type_t *>(param_value) = UR_DEVICE_TYPE_GPU;
    if (param_value_size_ret)
      *param_value_size_ret = sizeof(UR_DEVICE_TYPE_GPU);
    return UR_RESULT_SUCCESS;
  }
  case UR_DEVICE_INFO_NAME: {
    if (param_value) {
      assert(param_value_size == sizeof(MockDeviceName));
      std::memcpy(param_value, MockDeviceName, sizeof(MockDeviceName));
    }
    if (param_value_size_ret)
      *param_value_size_ret = sizeof(MockDeviceName);
    return UR_RESULT_SUCCESS;
  }
  case UR_DEVICE_INFO_PARENT_DEVICE: {
    if (param_value)
      *static_cast<ur_device_handle_t *>(param_value) = nullptr;
    if (param_value_size_ret)
      *param_value_size_ret = sizeof(ur_device_handle_t *);
    return UR_RESULT_SUCCESS;
  }
  case UR_DEVICE_INFO_EXTENSIONS: {
    if (param_value) {
      assert(param_value_size >= sizeof(MockSupportedExtensions));
      std::memcpy(param_value, MockSupportedExtensions,
                  sizeof(MockSupportedExtensions));
    }
    if (param_value_size_ret)
      *param_value_size_ret = sizeof(MockSupportedExtensions);
    return UR_RESULT_SUCCESS;
  }
  case UR_DEVICE_INFO_USM_HOST_SUPPORT:
  case UR_DEVICE_INFO_USM_DEVICE_SUPPORT:
  case UR_DEVICE_INFO_USM_SINGLE_SHARED_SUPPORT:
  case UR_DEVICE_INFO_HOST_UNIFIED_MEMORY:
  case UR_DEVICE_INFO_AVAILABLE:
  case UR_DEVICE_INFO_LINKER_AVAILABLE:
  case UR_DEVICE_INFO_COMPILER_AVAILABLE:
  case UR_DEVICE_INFO_COMMAND_BUFFER_SUPPORT_EXP:
  case UR_DEVICE_INFO_COMMAND_BUFFER_UPDATE_SUPPORT_EXP: {
    if (param_value)
      *static_cast<ur_bool_t *>(param_value) = true;
    if (param_value_size_ret)
      *param_value_size_ret = sizeof(true);
    return UR_RESULT_SUCCESS;
  }
  // This mock GPU device has no sub-devices
  case UR_DEVICE_INFO_SUPPORTED_PARTITIONS: {
    if (param_value_size_ret) {
      *param_value_size_ret = 0;
    }
    return UR_RESULT_SUCCESS;
  }
  case UR_DEVICE_INFO_PARTITION_AFFINITY_DOMAIN: {
    assert(param_value_size == sizeof(ur_device_affinity_domain_flags_t));
    if (param_value) {
      *static_cast<ur_device_affinity_domain_flags_t *>(param_value) = 0;
    }
    return UR_RESULT_SUCCESS;
  }
  case UR_DEVICE_INFO_QUEUE_PROPERTIES: {
    assert(param_value_size == sizeof(ur_queue_flags_t));
    if (param_value) {
      *static_cast<ur_queue_flags_t *>(param_value) =
          UR_QUEUE_FLAG_PROFILING_ENABLE;
    }
    return UR_RESULT_SUCCESS;
  }
  default: {
    // In the default case we fill the return value with 0's. This may not be
    // valid for all device queries, but it will mean a consistent return value
    // for the query.
    // Any tests that need special return values should either add behavior
    // the this function or use redefineAfter with a function that adds the
    // intended behavior.
    if (param_value && param_value_size != 0)
      std::memset(param_value, 0, param_value_size);
    // Likewise, if the device info query asks for the size of the return value
    // we tell it there is a single byte to avoid cases where the runtime tries
    // to allocate some random amount of memory for the return value.
    if (param_value_size_ret)
      *param_value_size_ret = 1;
    return UR_RESULT_SUCCESS;
  }
  }
}

inline ur_result_t mock_urProgramGetInfo(ur_program_handle_t program,
                                         ur_program_info_t param_name,
                                         size_t param_value_size,
                                         void *param_value,
                                         size_t *param_value_size_ret) {
  switch (param_name) {
  case UR_PROGRAM_INFO_NUM_DEVICES: {
    if (param_value)
      *static_cast<unsigned int *>(param_value) = 1;
    if (param_value_size_ret)
      *param_value_size_ret = sizeof(size_t);
    return UR_RESULT_SUCCESS;
  }
  case UR_PROGRAM_INFO_BINARY_SIZES: {
    if (param_value)
      *static_cast<size_t *>(param_value) = 1;
    if (param_value_size_ret)
      *param_value_size_ret = sizeof(size_t);
    return UR_RESULT_SUCCESS;
  }
  case UR_PROGRAM_INFO_BINARIES: {
    if (param_value)
      **static_cast<unsigned char **>(param_value) = 1;
    if (param_value_size_ret)
      *param_value_size_ret = sizeof(unsigned char);
    return UR_RESULT_SUCCESS;
  }
  default: {
    // TODO: Buildlog requires this but not any actual data afterwards.
    //       This should be investigated. Should this be moved to that test?
    if (param_value_size_ret)
      *param_value_size_ret = sizeof(size_t);
    return UR_RESULT_SUCCESS;
  }
  }
}

inline ur_result_t mock_urContextGetInfo(ur_context_handle_t context,
                                         ur_context_info_t param_name,
                                         size_t param_value_size,
                                         void *param_value,
                                         size_t *param_value_size_ret) {
  switch (param_name) {
  case UR_CONTEXT_INFO_NUM_DEVICES: {
    if (param_value)
      *static_cast<uint32_t *>(param_value) = 1;
    if (param_value_size_ret)
      *param_value_size_ret = sizeof(uint32_t);
    return UR_RESULT_SUCCESS;
  }
  default:
    return UR_RESULT_SUCCESS;
  }
}

inline ur_result_t mock_urQueueGetInfo(ur_queue_handle_t command_queue,
                                       ur_queue_info_t param_name,
                                       size_t param_value_size,
                                       void *param_value,
                                       size_t *param_value_size_ret) {
  switch (param_name) {
  case UR_QUEUE_INFO_DEVICE: {
    if (param_value)
      *static_cast<ur_device_handle_t *>(param_value) =
          reinterpret_cast<ur_device_handle_t>(1);
    if (param_value_size_ret)
      *param_value_size_ret = sizeof(ur_device_handle_t);
    return UR_RESULT_SUCCESS;
  }
  default:
    return UR_RESULT_SUCCESS;
  }
}

inline ur_result_t mock_urKernelGetGroupInfo(ur_kernel_handle_t kernel,
                                             ur_device_handle_t device,
                                             ur_kernel_group_info_t param_name,
                                             size_t param_value_size,
                                             void *param_value,
                                             size_t *param_value_size_ret) {
  switch (param_name) {
  case UR_KERNEL_GROUP_INFO_WORK_GROUP_SIZE: {
    if (param_value) {
      auto RealVal = reinterpret_cast<size_t *>(param_value);
      RealVal[0] = 0;
      RealVal[1] = 0;
      RealVal[2] = 0;
    }
    if (param_value_size_ret)
      *param_value_size_ret = 3 * sizeof(size_t);
    return UR_RESULT_SUCCESS;
  }
  default: {
    return UR_RESULT_SUCCESS;
  }
  }
}

inline ur_result_t mock_urEventGetInfo(ur_event_handle_t event,
                                       ur_event_info_t param_name,
                                       size_t param_value_size,
                                       void *param_value,
                                       size_t *param_value_size_ret) {
  switch (param_name) {
  case UR_EVENT_INFO_COMMAND_EXECUTION_STATUS: {
    if (param_value)
      *static_cast<ur_event_status_t *>(param_value) =
          UR_EVENT_STATUS_SUBMITTED;
    if (param_value_size_ret)
      *param_value_size_ret = sizeof(ur_event_status_t);
    return UR_RESULT_SUCCESS;
  }
  default: {
    return UR_RESULT_SUCCESS;
  }
  }
}

inline ur_result_t mock_urKernelSuggestMaxCooperativeGroupCountExp(
    ur_kernel_handle_t kernel, size_t local_work_size, size_t dynamic_shared_memory_size,
    uint32_t *group_count_ret) {
  *group_count_ret = 1;
  return UR_RESULT_SUCCESS;
}

inline ur_result_t mock_urDeviceSelectBinary(ur_device_handle_t device,
                                              ur_device_binary_t *binaries,
                                              uint32_t num_binaries,
                                              uint32_t *selected_binary_ind) {
  *selected_binary_ind = 0;
  return UR_RESULT_SUCCESS;
}

inline ur_result_t mock_urPlatformGetBackendOption(ur_platform_handle_t platform,
                                               const char *frontend_option,
                                               const char **backend_option) {
  *backend_option = "";
  return UR_RESULT_SUCCESS;
}

// Returns the wall-clock timestamp of host for deviceTime and hostTime
inline ur_result_t mock_urDeviceGetGlobalTimestamps(ur_device_handle_t device,
                                              uint64_t *deviceTime,
                                              uint64_t *hostTime) {

  using namespace std::chrono;
  auto timeNanoseconds =
      duration_cast<nanoseconds>(steady_clock::now().time_since_epoch())
          .count();
  if (deviceTime) {
    *deviceTime = timeNanoseconds;
  }
  if (hostTime) {
    *hostTime = timeNanoseconds;
  }
  return UR_RESULT_SUCCESS;
}

inline ur_result_t
mock_urUsmP2PPeerAccessGetInfoExp(ur_device_handle_t command_device, ur_device_handle_t peer_device,
                            ur_exp_peer_info_t attr, size_t param_value_size,
                            void *param_value, size_t *param_value_size_ret) {
  if (param_value)
    *static_cast<int32_t *>(param_value) = 1;
  if (param_value_size_ret)
    *param_value_size_ret = sizeof(int32_t);

  return UR_RESULT_SUCCESS;
}
/*
inline pi_result
mock_piMemBufferCreate(pi_context context, pi_mem_flags flags, size_t size,
                       void *host_ptr, pi_mem *ret_mem,
                       const pi_mem_properties *properties = nullptr) {
  if (host_ptr && flags & PI_MEM_FLAGS_HOST_PTR_USE)
    *ret_mem = createDummyHandleWithData<pi_mem>(
        reinterpret_cast<unsigned char *>(host_ptr));
  else
    *ret_mem = createDummyHandle<pi_mem>(size);
  return PI_SUCCESS;
}

inline pi_result mock_piMemImageCreate(pi_context context, pi_mem_flags flags,
                                       const pi_image_format *image_format,
                                       const pi_image_desc *image_desc,
                                       void *host_ptr, pi_mem *ret_mem) {
  assert(false &&
         "TODO: mock_piMemImageCreate handle allocation size correctly");
  *ret_mem = createDummyHandle<pi_mem>(1024 * 16);
  return PI_SUCCESS;
}

inline pi_result
mock_piMemBufferPartition(pi_mem buffer, pi_mem_flags flags,
                          pi_buffer_create_type buffer_create_type,
                          void *buffer_create_info, pi_mem *ret_mem) {
  // Create a sub buf without memory as we will reuse parent's one
  *ret_mem = createDummyHandle<pi_mem>(0);

  auto parentDummyHandle = reinterpret_cast<DummyHandlePtrT>(buffer);
  auto childDummyHandle = reinterpret_cast<DummyHandlePtrT>(*ret_mem);

  auto region = reinterpret_cast<pi_buffer_region>(buffer_create_info);

  // Point the sub buf to the original buf memory
  childDummyHandle->MData = parentDummyHandle->MData + region->origin;

  return PI_SUCCESS;
}

inline pi_result mock_piEnqueueMemBufferMap(pi_queue command_queue,
                                            pi_mem buffer, pi_bool blocking_map,
                                            pi_map_flags map_flags,
                                            size_t offset, size_t size,
                                            uint32_t num_events_in_wait_list,
                                            const pi_event *event_wait_list,
                                            pi_event *event, void **ret_map) {
  *event = createDummyHandle<pi_event>();

  auto parentDummyHandle = reinterpret_cast<DummyHandlePtrT>(buffer);
  *ret_map = (void *)(parentDummyHandle->MData);
  return PI_SUCCESS;
}

///
// USM
///
inline pi_result mock_piextUSMHostAlloc(void **result_ptr, pi_context context,
                                        pi_usm_mem_properties *properties,
                                        size_t size, uint32_t alignment) {
  assert(alignment < 16 && "TODO: mock_piextUSMHostAlloc handle alignment");
  *result_ptr = createDummyHandle<void *>(size);
  return PI_SUCCESS;
}

inline pi_result mock_piextUSMDeviceAlloc(void **result_ptr, pi_context context,
                                          pi_device device,
                                          pi_usm_mem_properties *properties,
                                          size_t size, uint32_t alignment) {
  assert(alignment < 16 && "TODO: mock_piextUSMHostAlloc handle alignment");
  *result_ptr = createDummyHandle<void *>(size);
  return PI_SUCCESS;
}

inline pi_result mock_piextUSMSharedAlloc(void **result_ptr, pi_context context,
                                          pi_device device,
                                          pi_usm_mem_properties *properties,
                                          size_t size, uint32_t alignment) {
  assert(alignment < 16 && "TODO: mock_piextUSMHostAlloc handle alignment");
  *result_ptr = createDummyHandle<void *>(size);
  return PI_SUCCESS;
}

inline pi_result mock_piextUSMPitchedAlloc(void **result_ptr,
                                           size_t *result_pitch,
                                           pi_context context, pi_device device,
                                           pi_usm_mem_properties *properties,
                                           size_t width_in_bytes, size_t height,
                                           unsigned int element_size_bytes) {
  *result_ptr = createDummyHandle<void *>(width_in_bytes * height);
  return PI_SUCCESS;
}

*/
